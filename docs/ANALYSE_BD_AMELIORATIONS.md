# üìä ANALYSE ET AM√âLIORATIONS - BASE DE DONN√âES UniCity

**Date :** 2025-12-06
**Version BD analys√©e :** BD_amelioree.sql v2.0
**Projet :** Application UniCity - Master 2 MIAGe 2026

---

## üìã SOMMAIRE

1. [R√©sum√© ex√©cutif](#r√©sum√©-ex√©cutif)
2. [Analyse de correspondance avec le cahier des charges](#analyse-de-correspondance)
3. [Bugs critiques √† corriger](#bugs-critiques)
4. [Am√©liorations recommand√©es](#am√©liorations-recommand√©es)
5. [Optimisations de performance](#optimisations)
6. [S√©curit√© et RGPD](#s√©curit√©-rgpd)
7. [√âvolutivit√© pour V2](#√©volutivit√©)
8. [Script SQL des corrections](#script-corrections)

---

## 1. R√âSUM√â EX√âCUTIF

### ‚úÖ Points forts
- Architecture multi-tenant bien con√ßue (multi-villes)
- Couverture fonctionnelle √† 95% du cahier des charges
- Bonne normalisation (3NF)
- Index de performance pr√©sents
- Contraintes d'int√©grit√© robustes
- Support RGPD avec logs d'actions

### ‚ö†Ô∏è Points d'attention
- **1 bug critique** √† corriger imm√©diatement (votes sondages)
- Quelques tables manquantes pour fonctionnalit√©s avanc√©es
- Certains champs pourraient √™tre optimis√©s
- Tra√ßabilit√© √† am√©liorer pour certaines entit√©s

### üìä Score global : **8.5/10**

---

## 2. ANALYSE DE CORRESPONDANCE

### ‚úÖ Fonctionnalit√©s parfaitement couvertes

| Cahier des charges | Tables BD | Statut |
|-------------------|-----------|--------|
| Authentification multi-profils | `utilisateurs.role` | ‚úÖ |
| Personnalisation par ville | `villes` (logo, slogan, couleurs) | ‚úÖ |
| Signalements citoyens | `signalements` | ‚úÖ |
| GPS/Localisation | `signalements` (lat/long) | ‚úÖ |
| Sondages multi-questions | `sondages`, `questions_sondage`, `reponses_sondage` | ‚úÖ |
| Filtrage g√©ographique | `quartiers` | ‚úÖ |
| Filtrage par cat√©gorie | `categories_citoyens` | ‚úÖ |
| Agenda √©v√©nements | `evenements`, `thematiques_evenement` | ‚úÖ |
| Calendrier personnel | `evenements_utilisateur` | ‚úÖ |
| Actualit√©s r√©seaux sociaux | `actualites`, `reseaux_sociaux` | ‚úÖ |
| Tra√ßabilit√© RGPD | `logs_actions` | ‚úÖ |

---

## 3. BUGS CRITIQUES √Ä CORRIGER

### üö® BUG #1 : Contrainte UNIQUE incorrecte dans `votes_sondage`

**Ligne 112 du script SQL :**
```sql
UNIQUE ("sondage_id", "citoyen_id", "reponse_id")
```

**Probl√®me :**
Cette contrainte emp√™che un citoyen de r√©pondre √† plusieurs questions d'un m√™me sondage.

**Sc√©nario probl√©matique :**
```
Sondage : "Am√©lioration du parc municipal"
‚îú‚îÄ Question 1 : "Pr√©f√©rez-vous : A) Aire de jeux  B) Terrain de sport"
‚îÇ  ‚îî‚îÄ Citoyen vote : R√©ponse A ‚Üí ‚úÖ OK
‚îî‚îÄ Question 2 : "Horaires souhait√©s : A) 8h-20h  B) 8h-22h"
   ‚îî‚îÄ Citoyen vote : R√©ponse A ‚Üí ‚ùå ERREUR : violation de contrainte UNIQUE
```

**Impact :** üî¥ **BLOQUANT** - Les sondages multi-questions sont inutilisables

**Solution :**
```sql
-- ‚ùå AVANT (incorrect)
UNIQUE ("sondage_id", "citoyen_id", "reponse_id")

-- ‚úÖ APR√àS (correct)
-- Option 1 : Un citoyen peut voter UNE FOIS par question
UNIQUE ("question_id", "citoyen_id")

-- Option 2 : Plus flexible, permet de changer son vote
-- Ajouter un champ question_id dans votes_sondage
-- et g√©rer l'unicit√© au niveau applicatif
```

**Recommandation :** Impl√©menter l'Option 1 (simple et robuste)

---

### üö® BUG #2 : Incoh√©rence dans la structure des votes

**Probl√®me :**
Le champ `reponse_id` dans `votes_sondage` r√©f√©rence `reponses_sondage`, mais il manque le lien avec `question_id`.

**Structure actuelle :**
```
votes_sondage
‚îú‚îÄ sondage_id (r√©f√©rence sondages)
‚îú‚îÄ citoyen_id (r√©f√©rence utilisateurs)
‚îî‚îÄ reponse_id (r√©f√©rence reponses_sondage)
   ‚îî‚îÄ ‚ö†Ô∏è Mais reponses_sondage.question_id n'est pas v√©rifiable !
```

**Impact :** üü° **MOYEN** - Risque de votes incoh√©rents (r√©ponse d'une autre question)

**Solution :**
```sql
-- Ajouter une contrainte de coh√©rence
ALTER TABLE votes_sondage
  ADD CONSTRAINT check_vote_coherence
  CHECK (
    -- V√©rifier que reponse_id appartient bien au bon sondage
    -- (via trigger ou au niveau applicatif)
  );

-- OU mieux : restructurer
ALTER TABLE votes_sondage
  ADD COLUMN question_id INT NOT NULL REFERENCES questions_sondage(id);
```

---

## 4. AM√âLIORATIONS RECOMMAND√âES

### üìÅ Am√©lioration #1 : Gestion des fichiers upload√©s

**Probl√®me actuel :**
- `signalements.photo_url` stocke juste une URL (VARCHAR)
- Pas de tra√ßabilit√© des fichiers
- Pas de gestion de la taille/type
- Risque de fichiers orphelins

**Solution : Cr√©er une table `fichiers`**

```sql
CREATE TABLE fichiers (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nom_original VARCHAR(255) NOT NULL,
  nom_stockage VARCHAR(255) NOT NULL UNIQUE, -- UUID g√©n√©r√©
  chemin VARCHAR(500) NOT NULL,
  type_mime VARCHAR(100) NOT NULL, -- image/jpeg, application/pdf
  taille_octets BIGINT NOT NULL,
  hash_sha256 VARCHAR(64), -- D√©tection doublons
  upload√©_par INT NOT NULL REFERENCES utilisateurs(id),
  date_upload TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT check_taille CHECK (taille_octets <= 10485760) -- Max 10MB
);

-- Modifier signalements
ALTER TABLE signalements
  DROP COLUMN photo_url,
  ADD COLUMN fichier_id INT REFERENCES fichiers(id) ON DELETE SET NULL;

-- Permet d'avoir plusieurs photos par signalement (future V2)
CREATE TABLE signalements_fichiers (
  signalement_id INT REFERENCES signalements(id) ON DELETE CASCADE,
  fichier_id INT REFERENCES fichiers(id) ON DELETE CASCADE,
  PRIMARY KEY (signalement_id, fichier_id)
);
```

**Avantages :**
- ‚úÖ Tra√ßabilit√© compl√®te
- ‚úÖ Contr√¥le de taille/type
- ‚úÖ D√©tection des doublons (via hash)
- ‚úÖ Support multi-photos (extensible)

---

### üìú Am√©lioration #2 : Historique des signalements

**Besoin :** Tracer les changements d'√©tat des signalements

```sql
CREATE TABLE historique_signalements (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  signalement_id INT NOT NULL REFERENCES signalements(id) ON DELETE CASCADE,
  ancien_etat VARCHAR(50),
  nouvel_etat VARCHAR(50) NOT NULL,
  commentaire TEXT,
  modifie_par INT REFERENCES utilisateurs(id) ON DELETE SET NULL,
  date_modification TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Index pour requ√™tes fr√©quentes
CREATE INDEX idx_historique_signalement ON historique_signalements(signalement_id);
CREATE INDEX idx_historique_date ON historique_signalements(date_modification);
```

**Cas d'usage :**
- Voir qui a trait√© un signalement et quand
- Statistiques sur les d√©lais de traitement
- Conformit√© RGPD (tra√ßabilit√© compl√®te)

---

### üë§ Am√©lioration #3 : Profils utilisateurs enrichis

**Probl√®me actuel :**
- Pas de photo de profil
- Pas de t√©l√©phone
- Pas de date de naissance (utile pour ciblage seniors)

```sql
ALTER TABLE utilisateurs
  ADD COLUMN telephone VARCHAR(20),
  ADD COLUMN date_naissance DATE,
  ADD COLUMN photo_profil_id INT REFERENCES fichiers(id) ON DELETE SET NULL,
  ADD COLUMN consentement_rgpd BOOLEAN DEFAULT false NOT NULL,
  ADD COLUMN date_consentement_rgpd TIMESTAMP,
  ADD COLUMN derniere_connexion TIMESTAMP,
  ADD COLUMN compte_actif BOOLEAN DEFAULT true;

-- Index pour recherches
CREATE INDEX idx_utilisateurs_telephone ON utilisateurs(telephone);
CREATE INDEX idx_utilisateurs_actif ON utilisateurs(compte_actif);
```

---

### üîî Am√©lioration #4 : Syst√®me de notifications

**Besoin :** Notifier les citoyens (nouveau sondage, signalement r√©solu, etc.)

```sql
CREATE TABLE notifications (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  destinataire_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  titre VARCHAR(255) NOT NULL,
  message TEXT NOT NULL,
  type VARCHAR(50) NOT NULL CHECK (type IN (
    'signalement_resolu',
    'nouveau_sondage',
    'nouvel_evenement',
    'reponse_agent'
  )),
  lue BOOLEAN DEFAULT false,
  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  date_lecture TIMESTAMP
);

CREATE INDEX idx_notifications_destinataire ON notifications(destinataire_id);
CREATE INDEX idx_notifications_non_lues ON notifications(destinataire_id, lue)
  WHERE lue = false;
```

---

### üìä Am√©lioration #5 : Statistiques et analytics

**Besoin :** Dashboard pour les √©lus (KPIs, statistiques)

```sql
CREATE TABLE statistiques_ville (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ville_id INT NOT NULL REFERENCES villes(id) ON DELETE CASCADE,
  periode_debut DATE NOT NULL,
  periode_fin DATE NOT NULL,
  nb_signalements_total INT DEFAULT 0,
  nb_signalements_resolus INT DEFAULT 0,
  nb_utilisateurs_actifs INT DEFAULT 0,
  nb_votes_sondages INT DEFAULT 0,
  taux_participation_moyen DECIMAL(5,2), -- en %
  date_calcul TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT check_periode CHECK (periode_fin >= periode_debut)
);

CREATE INDEX idx_stats_ville ON statistiques_ville(ville_id, periode_debut);
```

**Note :** Peut √™tre g√©n√©r√© via une proc√©dure stock√©e ou un job planifi√©

---

### üó£Ô∏è Am√©lioration #6 : Commentaires sur signalements

**Besoin :** √âchanges citoyen ‚Üî agent municipal

```sql
CREATE TABLE commentaires_signalement (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  signalement_id INT NOT NULL REFERENCES signalements(id) ON DELETE CASCADE,
  auteur_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  contenu TEXT NOT NULL,
  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  modifie BOOLEAN DEFAULT false,
  date_modification TIMESTAMP
);

CREATE INDEX idx_commentaires_signalement ON commentaires_signalement(signalement_id);
```

---

### üìç Am√©lioration #7 : Am√©lioration g√©olocalisation

**Probl√®me actuel :**
- Pas de validation des coordonn√©es GPS
- Pas d'adresse textuelle associ√©e

```sql
ALTER TABLE signalements
  ADD COLUMN adresse VARCHAR(500), -- Geocoding inverse (lat/long ‚Üí adresse)
  ADD CONSTRAINT check_latitude CHECK (latitude BETWEEN -90 AND 90),
  ADD CONSTRAINT check_longitude CHECK (longitude BETWEEN -180 AND 180);

-- Index spatial pour recherches g√©ographiques
CREATE INDEX idx_signalements_geo ON signalements(latitude, longitude);
```

---

### üîê Am√©lioration #8 : S√©curit√© renforc√©e

**Tokens de r√©initialisation mot de passe**

```sql
CREATE TABLE tokens_reset_password (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  utilisateur_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  token VARCHAR(255) NOT NULL UNIQUE,
  date_expiration TIMESTAMP NOT NULL,
  utilise BOOLEAN DEFAULT false,
  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT check_expiration CHECK (date_expiration > date_creation)
);

CREATE INDEX idx_tokens_valides ON tokens_reset_password(token, date_expiration, utilise)
  WHERE utilise = false;
```

**Sessions utilisateurs (alternative aux JWT)**

```sql
CREATE TABLE sessions (
  id VARCHAR(255) PRIMARY KEY, -- Session ID
  utilisateur_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  adresse_ip VARCHAR(45),
  user_agent VARCHAR(500),
  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  date_expiration TIMESTAMP NOT NULL,
  derniere_activite TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sessions_utilisateur ON sessions(utilisateur_id);
CREATE INDEX idx_sessions_expiration ON sessions(date_expiration);
```

---

### üì± Am√©lioration #9 : Support multi-langues

**Pour villes avec population internationale**

```sql
CREATE TABLE langues (
  code VARCHAR(5) PRIMARY KEY, -- 'fr', 'en', 'es', 'ar'
  nom VARCHAR(100) NOT NULL
);

CREATE TABLE traductions (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  table_source VARCHAR(100) NOT NULL, -- 'evenements', 'actualites', etc.
  id_source INT NOT NULL, -- ID de l'enregistrement traduit
  champ VARCHAR(100) NOT NULL, -- 'titre', 'description', etc.
  langue_code VARCHAR(5) NOT NULL REFERENCES langues(code),
  traduction TEXT NOT NULL,
  UNIQUE (table_source, id_source, champ, langue_code)
);

ALTER TABLE utilisateurs
  ADD COLUMN langue_preferee VARCHAR(5) DEFAULT 'fr' REFERENCES langues(code);
```

---

### üìß Am√©lioration #10 : Contact/Messages directs

**Communication √©lu ‚Üî citoyen**

```sql
CREATE TABLE messages (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  expediteur_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  destinataire_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  sujet VARCHAR(255) NOT NULL,
  contenu TEXT NOT NULL,
  lu BOOLEAN DEFAULT false,
  date_envoi TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  date_lecture TIMESTAMP,
  parent_message_id INT REFERENCES messages(id) ON DELETE SET NULL -- Pour fils de discussion
);

CREATE INDEX idx_messages_destinataire ON messages(destinataire_id, lu);
CREATE INDEX idx_messages_conversation ON messages(parent_message_id);
```

---

## 5. OPTIMISATIONS DE PERFORMANCE

### üöÄ Index composites suppl√©mentaires

```sql
-- Recherche de signalements par quartier et √©tat
CREATE INDEX idx_signalements_quartier_etat
  ON signalements(quartier_id, etat);

-- √âv√©nements actifs par ville
CREATE INDEX idx_evenements_ville_dates
  ON evenements(ville_id, date_debut, date_fin);

-- Sondages actifs par ville
CREATE INDEX idx_sondages_actifs
  ON sondages(ville_id, date_debut, date_fin)
  WHERE date_fin >= CURRENT_TIMESTAMP;

-- Logs r√©cents par utilisateur
CREATE INDEX idx_logs_utilisateur_recent
  ON logs_actions(utilisateur_id, date_action DESC);
```

### üìä Vues mat√©rialis√©es (pour rapports)

```sql
-- Vue : Statistiques signalements par quartier
CREATE MATERIALIZED VIEW vue_stats_signalements_quartier AS
SELECT
  q.id AS quartier_id,
  q.nom AS quartier_nom,
  v.id AS ville_id,
  v.nom_ville,
  COUNT(s.id) AS nb_total,
  COUNT(s.id) FILTER (WHERE s.etat = 'resolu') AS nb_resolus,
  COUNT(s.id) FILTER (WHERE s.etat = 'en_cours') AS nb_en_cours,
  COUNT(s.id) FILTER (WHERE s.etat = 'enregistre') AS nb_en_attente,
  ROUND(
    100.0 * COUNT(s.id) FILTER (WHERE s.etat = 'resolu') / NULLIF(COUNT(s.id), 0),
    2
  ) AS taux_resolution_pct
FROM quartiers q
JOIN villes v ON q.ville_id = v.id
LEFT JOIN signalements s ON s.quartier_id = q.id
GROUP BY q.id, q.nom, v.id, v.nom_ville;

-- Index sur la vue
CREATE INDEX idx_vue_stats_quartier ON vue_stats_signalements_quartier(ville_id);

-- Rafra√Æchir la vue (√† planifier quotidiennement)
REFRESH MATERIALIZED VIEW vue_stats_signalements_quartier;
```

### üóëÔ∏è Politique d'archivage

```sql
-- Table d'archivage pour anciennes donn√©es
CREATE TABLE signalements_archives (
  LIKE signalements INCLUDING ALL
);

CREATE TABLE sondages_archives (
  LIKE sondages INCLUDING ALL
);

-- Fonction de nettoyage automatique (√† ex√©cuter mensuellement)
CREATE OR REPLACE FUNCTION archiver_anciennes_donnees()
RETURNS void AS $$
BEGIN
  -- Archiver signalements > 2 ans
  INSERT INTO signalements_archives
  SELECT * FROM signalements
  WHERE date_creation < CURRENT_DATE - INTERVAL '2 years';

  DELETE FROM signalements
  WHERE date_creation < CURRENT_DATE - INTERVAL '2 years';

  -- Archiver sondages clos > 1 an
  INSERT INTO sondages_archives
  SELECT * FROM sondages
  WHERE date_fin < CURRENT_DATE - INTERVAL '1 year';

  DELETE FROM sondages
  WHERE date_fin < CURRENT_DATE - INTERVAL '1 year';
END;
$$ LANGUAGE plpgsql;
```

---

## 6. S√âCURIT√â ET RGPD

### üîê Am√©lioration #11 : Anonymisation RGPD

```sql
-- Table pour demandes RGPD
CREATE TABLE demandes_rgpd (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  utilisateur_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  type_demande VARCHAR(50) NOT NULL CHECK (type_demande IN (
    'export_donnees',      -- Droit d'acc√®s
    'suppression_compte',  -- Droit √† l'oubli
    'rectification'        -- Droit de rectification
  )),
  statut VARCHAR(50) DEFAULT 'en_attente' CHECK (statut IN (
    'en_attente',
    'en_cours',
    'traitee',
    'rejetee'
  )),
  date_demande TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  date_traitement TIMESTAMP,
  traite_par INT REFERENCES utilisateurs(id),
  commentaire TEXT
);

-- Fonction d'anonymisation
CREATE OR REPLACE FUNCTION anonymiser_utilisateur(user_id INT)
RETURNS void AS $$
BEGIN
  UPDATE utilisateurs
  SET
    nom = 'ANONYME',
    prenom = 'ANONYME',
    email = 'anonyme_' || user_id || '@deleted.local',
    mot_de_passe_hash = '',
    adresse = NULL,
    telephone = NULL,
    date_naissance = NULL,
    compte_actif = false
  WHERE id = user_id;

  -- Anonymiser les logs
  UPDATE logs_actions
  SET adresse_ip = '0.0.0.0'
  WHERE utilisateur_id = user_id;
END;
$$ LANGUAGE plpgsql;
```

### üîí Chiffrement de donn√©es sensibles

```sql
-- Activer l'extension pgcrypto
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Exemple : chiffrer le num√©ro de t√©l√©phone
ALTER TABLE utilisateurs
  ADD COLUMN telephone_chiffre BYTEA;

-- Fonctions helper
CREATE OR REPLACE FUNCTION chiffrer_telephone(numero VARCHAR)
RETURNS BYTEA AS $$
BEGIN
  RETURN pgp_sym_encrypt(numero, current_setting('app.encryption_key'));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION dechiffrer_telephone(donnee_chiffree BYTEA)
RETURNS VARCHAR AS $$
BEGIN
  RETURN pgp_sym_decrypt(donnee_chiffree, current_setting('app.encryption_key'));
END;
$$ LANGUAGE plpgsql;
```

---

## 7. √âVOLUTIVIT√â POUR V2

### üåü Fonctionnalit√©s futures sugg√©r√©es

**A. Module de p√©titions en ligne**
```sql
CREATE TABLE petitions (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  titre VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  objectif_signatures INT NOT NULL,
  ville_id INT NOT NULL REFERENCES villes(id),
  createur_id INT NOT NULL REFERENCES utilisateurs(id),
  statut VARCHAR(50) DEFAULT 'active' CHECK (statut IN ('brouillon', 'active', 'cloturee', 'validee', 'rejetee')),
  date_debut TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  date_fin TIMESTAMP,
  reponse_officielle TEXT
);

CREATE TABLE signatures_petition (
  petition_id INT REFERENCES petitions(id) ON DELETE CASCADE,
  citoyen_id INT REFERENCES utilisateurs(id) ON DELETE CASCADE,
  date_signature TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  commentaire_public TEXT,
  PRIMARY KEY (petition_id, citoyen_id)
);
```

**B. Syst√®me de badges/gamification**
```sql
CREATE TABLE badges (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nom VARCHAR(100) NOT NULL,
  description TEXT,
  icone_url VARCHAR(500),
  critere JSON -- Ex: {"type": "signalements", "nombre": 10}
);

CREATE TABLE utilisateurs_badges (
  utilisateur_id INT REFERENCES utilisateurs(id) ON DELETE CASCADE,
  badge_id INT REFERENCES badges(id) ON DELETE CASCADE,
  date_obtention TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (utilisateur_id, badge_id)
);
```

**C. Budget participatif**
```sql
CREATE TABLE projets_participatifs (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  titre VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  montant_estime DECIMAL(12,2),
  quartier_id INT REFERENCES quartiers(id),
  ville_id INT NOT NULL REFERENCES villes(id),
  proposeur_id INT NOT NULL REFERENCES utilisateurs(id),
  statut VARCHAR(50) DEFAULT 'soumis' CHECK (statut IN (
    'soumis', 'en_etude', 'vote_en_cours', 'approuve', 'rejete', 'realise'
  )),
  date_soumission TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE votes_projet_participatif (
  projet_id INT REFERENCES projets_participatifs(id) ON DELETE CASCADE,
  citoyen_id INT REFERENCES utilisateurs(id) ON DELETE CASCADE,
  date_vote TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (projet_id, citoyen_id)
);
```

**D. R√©servation de services municipaux**
```sql
CREATE TABLE services_reservables (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nom VARCHAR(255) NOT NULL, -- Ex: "Salle des f√™tes", "Terrain de tennis"
  ville_id INT NOT NULL REFERENCES villes(id),
  capacite INT,
  tarif_heure DECIMAL(10,2),
  ouvert_reservation BOOLEAN DEFAULT true
);

CREATE TABLE reservations (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_id INT NOT NULL REFERENCES services_reservables(id),
  utilisateur_id INT NOT NULL REFERENCES utilisateurs(id),
  date_debut TIMESTAMP NOT NULL,
  date_fin TIMESTAMP NOT NULL,
  statut VARCHAR(50) DEFAULT 'en_attente' CHECK (statut IN (
    'en_attente', 'confirmee', 'annulee', 'refusee'
  )),
  montant_total DECIMAL(10,2),
  CONSTRAINT check_dates_resa CHECK (date_fin > date_debut)
);
```

---

## 8. SCRIPT SQL DES CORRECTIONS

### üõ†Ô∏è Script de correction du bug critique

```sql
-- ============================================================================
-- SCRIPT DE CORRECTION - BUG VOTES_SONDAGE
-- √Ä ex√©cuter AVANT la premi√®re utilisation de la base
-- ============================================================================

BEGIN;

-- 1. Supprimer l'ancienne contrainte incorrecte
ALTER TABLE votes_sondage
  DROP CONSTRAINT IF EXISTS votes_sondage_sondage_id_citoyen_id_reponse_id_key;

-- 2. Ajouter le champ question_id (devrait d√©j√† exister via reponse_id ‚Üí question_id)
-- Mais pour clarifier la structure :
ALTER TABLE votes_sondage
  ADD COLUMN IF NOT EXISTS question_id INT;

-- 3. Peupler question_id depuis reponses_sondage (si donn√©es existantes)
UPDATE votes_sondage v
SET question_id = r.question_id
FROM reponses_sondage r
WHERE v.reponse_id = r.id
  AND v.question_id IS NULL;

-- 4. Rendre question_id obligatoire
ALTER TABLE votes_sondage
  ALTER COLUMN question_id SET NOT NULL;

-- 5. Ajouter la cl√© √©trang√®re
ALTER TABLE votes_sondage
  ADD CONSTRAINT fk_votes_question
  FOREIGN KEY (question_id) REFERENCES questions_sondage(id) ON DELETE CASCADE;

-- 6. Ajouter la BONNE contrainte d'unicit√©
ALTER TABLE votes_sondage
  ADD CONSTRAINT unique_vote_par_question
  UNIQUE (sondage_id, citoyen_id, question_id);

-- 7. V√©rifier la coh√©rence des donn√©es
-- Un vote doit pointer vers une r√©ponse qui appartient √† la bonne question
ALTER TABLE votes_sondage
  ADD CONSTRAINT check_coherence_vote
  CHECK (
    -- Cette contrainte sera v√©rifi√©e au niveau applicatif
    -- car elle n√©cessite une jointure complexe
    true
  );

COMMIT;

-- ============================================================================
-- SCRIPT D'AM√âLIORATION - NOUVELLES TABLES
-- ============================================================================

BEGIN;

-- Table fichiers
CREATE TABLE IF NOT EXISTS fichiers (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nom_original VARCHAR(255) NOT NULL,
  nom_stockage VARCHAR(255) NOT NULL UNIQUE,
  chemin VARCHAR(500) NOT NULL,
  type_mime VARCHAR(100) NOT NULL,
  taille_octets BIGINT NOT NULL,
  hash_sha256 VARCHAR(64),
  upload√©_par INT NOT NULL REFERENCES utilisateurs(id),
  date_upload TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT check_taille_fichier CHECK (taille_octets <= 10485760)
);

-- Table historique signalements
CREATE TABLE IF NOT EXISTS historique_signalements (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  signalement_id INT NOT NULL REFERENCES signalements(id) ON DELETE CASCADE,
  ancien_etat VARCHAR(50),
  nouvel_etat VARCHAR(50) NOT NULL,
  commentaire TEXT,
  modifie_par INT REFERENCES utilisateurs(id) ON DELETE SET NULL,
  date_modification TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table notifications
CREATE TABLE IF NOT EXISTS notifications (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  destinataire_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  titre VARCHAR(255) NOT NULL,
  message TEXT NOT NULL,
  type VARCHAR(50) NOT NULL CHECK (type IN (
    'signalement_resolu',
    'nouveau_sondage',
    'nouvel_evenement',
    'reponse_agent'
  )),
  lue BOOLEAN DEFAULT false,
  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  date_lecture TIMESTAMP
);

-- Table commentaires signalements
CREATE TABLE IF NOT EXISTS commentaires_signalement (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  signalement_id INT NOT NULL REFERENCES signalements(id) ON DELETE CASCADE,
  auteur_id INT NOT NULL REFERENCES utilisateurs(id) ON DELETE CASCADE,
  contenu TEXT NOT NULL,
  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  modifie BOOLEAN DEFAULT false,
  date_modification TIMESTAMP
);

-- Index suppl√©mentaires
CREATE INDEX IF NOT EXISTS idx_fichiers_hash ON fichiers(hash_sha256);
CREATE INDEX IF NOT EXISTS idx_historique_signalement ON historique_signalements(signalement_id);
CREATE INDEX IF NOT EXISTS idx_notifications_destinataire ON notifications(destinataire_id);
CREATE INDEX IF NOT EXISTS idx_notifications_non_lues ON notifications(destinataire_id, lue) WHERE lue = false;
CREATE INDEX IF NOT EXISTS idx_commentaires_signalement ON commentaires_signalement(signalement_id);

COMMIT;

-- ============================================================================
-- SCRIPT D'AM√âLIORATION - COLONNES SUPPL√âMENTAIRES
-- ============================================================================

BEGIN;

-- Am√©liorations table utilisateurs
ALTER TABLE utilisateurs
  ADD COLUMN IF NOT EXISTS telephone VARCHAR(20),
  ADD COLUMN IF NOT EXISTS date_naissance DATE,
  ADD COLUMN IF NOT EXISTS consentement_rgpd BOOLEAN DEFAULT false NOT NULL,
  ADD COLUMN IF NOT EXISTS date_consentement_rgpd TIMESTAMP,
  ADD COLUMN IF NOT EXISTS derniere_connexion TIMESTAMP,
  ADD COLUMN IF NOT EXISTS compte_actif BOOLEAN DEFAULT true;

-- Am√©liorations table signalements
ALTER TABLE signalements
  ADD COLUMN IF NOT EXISTS adresse VARCHAR(500),
  ADD CONSTRAINT IF NOT EXISTS check_latitude CHECK (latitude BETWEEN -90 AND 90),
  ADD CONSTRAINT IF NOT EXISTS check_longitude CHECK (longitude BETWEEN -180 AND 180);

-- Index performance
CREATE INDEX IF NOT EXISTS idx_utilisateurs_telephone ON utilisateurs(telephone);
CREATE INDEX IF NOT EXISTS idx_utilisateurs_actif ON utilisateurs(compte_actif);
CREATE INDEX IF NOT EXISTS idx_signalements_quartier_etat ON signalements(quartier_id, etat);
CREATE INDEX IF NOT EXISTS idx_signalements_geo ON signalements(latitude, longitude);

COMMIT;
```

---

## 9. CHECKLIST AVANT D√âPLOIEMENT

### ‚úÖ Corrections critiques
- [ ] Corriger la contrainte UNIQUE dans `votes_sondage`
- [ ] Ajouter le champ `question_id` dans `votes_sondage`
- [ ] Tester les sondages multi-questions

### ‚úÖ Am√©liorations prioritaires (MVP)
- [ ] Table `fichiers` pour gestion uploads
- [ ] Table `historique_signalements` pour tra√ßabilit√©
- [ ] Table `notifications` pour alertes citoyens
- [ ] Colonnes suppl√©mentaires dans `utilisateurs` (t√©l√©phone, RGPD)

### ‚úÖ Optimisations
- [ ] Cr√©er index composites recommand√©s
- [ ] Configurer archivage donn√©es anciennes
- [ ] Cr√©er vues mat√©rialis√©es pour rapports

### ‚úÖ S√©curit√©
- [ ] Activer extension pgcrypto
- [ ] Impl√©menter syst√®me de sessions
- [ ] Cr√©er proc√©dure anonymisation RGPD

### ‚úÖ Pour V2 (optionnel)
- [ ] Module p√©titions
- [ ] Badges/gamification
- [ ] Budget participatif
- [ ] R√©servations services

---

## 10. PROCHAINES √âTAPES RECOMMAND√âES

### üìÖ Phase 1 : Corrections urgentes (Jour 1)
1. Ex√©cuter le script de correction du bug `votes_sondage`
2. Tester manuellement un sondage multi-questions
3. Valider avec l'√©quipe

### üìÖ Phase 2 : Am√©liorations MVP (Semaine 1)
1. Impl√©menter tables `fichiers`, `historique_signalements`, `notifications`
2. Modifier le code backend pour utiliser ces nouvelles tables
3. Tests d'int√©gration

### üìÖ Phase 3 : Optimisations (Semaine 2)
1. Cr√©er index composites
2. Impl√©menter vues mat√©rialis√©es
3. Tests de performance

### üìÖ Phase 4 : S√©curit√© & RGPD (Semaine 3)
1. Syst√®me de sessions
2. Proc√©dures RGPD
3. Audit de s√©curit√©

---

## üìû CONTACT ET SUPPORT

**Questions ou suggestions ?**
Contactez l'√©quipe technique du projet UniCity

**Version du document :** 1.0
**Derni√®re mise √† jour :** 2025-12-06
**Auteur :** Analyse automatique Claude Code

---

## üìö ANNEXES

### Annexe A : Diagramme ER am√©lior√©
_(√Ä g√©n√©rer avec un outil type dbdiagram.io ou draw.io)_

### Annexe B : Scripts de migration
_(Fournis dans la section 8 ci-dessus)_

### Annexe C : Exemples de requ√™tes SQL optimis√©es

```sql
-- R√©cup√©rer tous les signalements non r√©solus d'un quartier avec leurs commentaires
SELECT
  s.*,
  u.nom || ' ' || u.prenom AS citoyen_nom,
  COUNT(DISTINCT c.id) AS nb_commentaires,
  MAX(c.date_creation) AS dernier_commentaire
FROM signalements s
JOIN utilisateurs u ON s.citoyen_id = u.id
LEFT JOIN commentaires_signalement c ON c.signalement_id = s.id
WHERE s.quartier_id = 1
  AND s.etat != 'resolu'
GROUP BY s.id, u.nom, u.prenom
ORDER BY s.date_creation DESC;

-- Taux de participation aux sondages par quartier
SELECT
  q.nom AS quartier,
  COUNT(DISTINCT s.id) AS nb_sondages,
  COUNT(DISTINCT v.citoyen_id) AS nb_participants,
  COUNT(v.id) AS nb_votes_total,
  ROUND(
    100.0 * COUNT(DISTINCT v.citoyen_id) / NULLIF(
      (SELECT COUNT(*) FROM utilisateurs WHERE quartier_id = q.id AND role = 'citoyen'),
      0
    ),
    2
  ) AS taux_participation_pct
FROM quartiers q
LEFT JOIN sondages s ON s.quartier_id = q.id OR s.quartier_id IS NULL
LEFT JOIN votes_sondage v ON v.sondage_id = s.id
WHERE q.ville_id = 1
GROUP BY q.id, q.nom;

-- √âv√©nements √† venir avec nombre d'inscrits
SELECT
  e.*,
  t.nom AS thematique,
  COUNT(eu.utilisateur_id) AS nb_inscrits
FROM evenements e
JOIN thematiques_evenement t ON e.thematique_id = t.id
LEFT JOIN evenements_utilisateur eu ON eu.evenement_id = e.id
WHERE e.date_debut >= CURRENT_TIMESTAMP
  AND e.ville_id = 1
GROUP BY e.id, t.nom
ORDER BY e.date_debut;
```

---

**FIN DU DOCUMENT**
